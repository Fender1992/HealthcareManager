@inject ProtectedSessionStorage Session
@inject ProtectedLocalStorage Local
@using HealthcareManager.Data
@inject IJSRuntime JSRuntime
@inherits OwningComponentBase

<CascadingValue Value="@(this)">
    <div class="container">
        @Application
    </div>
</CascadingValue>

@code {
    [Inject]
    public NavigationManager NavigationManager { get; set; }
    [Inject]
    protected ILogger<AppState> Logger { get; set; }
    [Parameter]
    public RenderFragment Application { get; set; }
    public NotificationUtility Notifier { get; set; }
    public event Action OnChange;
    internal UserFormDTO CurrentUser { get; private set; }
    private bool Loading { get; set; } = false;

    protected override async Task OnInitializedAsync()
    {
        var app = Application.Target as App;
        if (app != null)
        {
            await SetSessionAsync("User", CurrentUser);
        }

        this.OnChange += StateHasChanged;
        await base.OnInitializedAsync();
    }


    public async ValueTask SetSessionAsync<T>(string key, T value)
    {
        try
        {
            await Local.SetAsync(key, value);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, ex.Message);
        }
    }
    public async ValueTask<T> GetSessionAsync<T>(string key)
    {
        try
        {
            var result = await Local.GetAsync<T>(key);
            return result.Value;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, ex.Message);
            return default(T);
        }
    }

    public async Task ClearCurrentUser()
    {
        CurrentUser = null;
        await Session.DeleteAsync("CurrentUser");
    }


    public async ValueTask SetLocalAsync<T>(string key, T value)
    {
        try 
        {
            await Local.SetAsync(key, value);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, ex.Message);
        }
    }
    public async ValueTask<T> GetLocalAsync<T>(string key)
    {
        try
        {
            var result = await Local.GetAsync<T>(key);
            return result.Value;
        }
        catch(Exception ex)
        {
            Logger.LogError(ex, ex.Message);
            return default(T);
        }
    }

    private void NotifyStateChanged() => OnChange?.Invoke();
    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
        this.OnChange -= StateHasChanged;
    }
}
